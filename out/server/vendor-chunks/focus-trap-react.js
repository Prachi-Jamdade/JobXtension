"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/focus-trap-react";
exports.ids = ["vendor-chunks/focus-trap-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js":
/*!****************************************************************!*\
  !*** ./node_modules/focus-trap-react/dist/focus-trap-react.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _assertThisInitialized(t);\n}\nfunction _assertThisInitialized(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n            value: t,\n            writable: !0,\n            configurable: !0\n        }\n    }), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n    }), e && _setPrototypeOf(t, e);\n}\nfunction _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n        return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\nvar _require = __webpack_require__(/*! focus-trap */ \"(ssr)/./node_modules/focus-trap/dist/focus-trap.esm.js\"), createFocusTrap = _require.createFocusTrap;\nvar _require2 = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\"), isFocusable = _require2.isFocusable;\nvar FocusTrap = /*#__PURE__*/ function(_React$Component) {\n    function FocusTrap(props) {\n        var _this;\n        _classCallCheck(this, FocusTrap);\n        _this = _callSuper(this, FocusTrap, [\n            props\n        ]);\n        /**\n     * Gets the node for the given option, which is expected to be an option that\n     *  can be either a DOM node, a string that is a selector to get a node, `false`\n     *  (if a node is explicitly NOT given), or a function that returns any of these\n     *  values.\n     * @param {string} optionName\n     * @returns {undefined | false | HTMLElement | SVGElement} Returns\n     *  `undefined` if the option is not specified; `false` if the option\n     *  resolved to `false` (node explicitly not given); otherwise, the resolved\n     *  DOM node.\n     * @throws {Error} If the option is set, not `false`, and is not, or does not\n     *  resolve to a node.\n     */ _defineProperty(_this, \"getNodeForOption\", function(optionName) {\n            var _this$internalOptions;\n            // use internal options first, falling back to original options\n            var optionValue = (_this$internalOptions = this.internalOptions[optionName]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName];\n            if (typeof optionValue === \"function\") {\n                for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    params[_key - 1] = arguments[_key];\n                }\n                optionValue = optionValue.apply(void 0, params);\n            }\n            if (optionValue === true) {\n                optionValue = undefined; // use default value\n            }\n            if (!optionValue) {\n                if (optionValue === undefined || optionValue === false) {\n                    return optionValue;\n                }\n                // else, empty string (invalid), null (invalid), 0 (invalid)\n                throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n            }\n            var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n            if (typeof optionValue === \"string\") {\n                var _this$getDocument;\n                node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue); // resolve to node, or null if fails\n                if (!node) {\n                    throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n                }\n            }\n            return node;\n        });\n        _this.handleDeactivate = _this.handleDeactivate.bind(_this);\n        _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_this);\n        _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_this);\n        // focus-trap options used internally when creating the trap\n        _this.internalOptions = {\n            // We need to hijack the returnFocusOnDeactivate option,\n            // because React can move focus into the element before we arrived at\n            // this lifecycle hook (e.g. with autoFocus inputs). So the component\n            // captures the previouslyFocusedElement in componentWillMount,\n            // then (optionally) returns focus to it in componentWillUnmount.\n            returnFocusOnDeactivate: false,\n            // the rest of these are also related to deactivation of the trap, and we\n            //  need to use them and control them as well\n            checkCanReturnFocus: null,\n            onDeactivate: _this.handleDeactivate,\n            onPostDeactivate: _this.handlePostDeactivate,\n            // we need to special-case this setting as well so that we can know if we should\n            //  NOT return focus if the trap gets auto-deactivated as the result of an\n            //  outside click (otherwise, we'll always think we should return focus because\n            //  of how we manage that flag internally here)\n            clickOutsideDeactivates: _this.handleClickOutsideDeactivates\n        };\n        // original options provided by the consumer\n        _this.originalOptions = {\n            // because of the above `internalOptions`, we maintain our own flag for\n            //  this option, and default it to `true` because that's focus-trap's default\n            returnFocusOnDeactivate: true,\n            // because of the above `internalOptions`, we keep these separate since\n            //  they're part of the deactivation process which we configure (internally) to\n            //  be shared between focus-trap and focus-trap-react\n            onDeactivate: null,\n            onPostDeactivate: null,\n            checkCanReturnFocus: null,\n            // the user's setting, defaulted to false since focus-trap defaults this to false\n            clickOutsideDeactivates: false\n        };\n        var focusTrapOptions = props.focusTrapOptions;\n        for(var optionName in focusTrapOptions){\n            if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n                continue;\n            }\n            if (optionName === \"returnFocusOnDeactivate\" || optionName === \"onDeactivate\" || optionName === \"onPostDeactivate\" || optionName === \"checkCanReturnFocus\" || optionName === \"clickOutsideDeactivates\") {\n                _this.originalOptions[optionName] = focusTrapOptions[optionName];\n                continue; // exclude from internalOptions\n            }\n            _this.internalOptions[optionName] = focusTrapOptions[optionName];\n        }\n        // if set, `{ target: Node, allowDeactivation: boolean }` where `target` is the outside\n        //  node that was clicked, and `allowDeactivation` is the result of the consumer's\n        //  option (stored in `this.originalOptions.clickOutsideDeactivates`, which may be a\n        //  function) whether to allow or deny auto-deactivation on click on this outside node\n        _this.outsideClick = null;\n        // elements from which to create the focus trap on mount; if a child is used\n        //  instead of the `containerElements` prop, we'll get the child's related\n        //  element when the trap renders and then is declared 'mounted'\n        _this.focusTrapElements = props.containerElements || [];\n        // now we remember what the currently focused element is, not relying on focus-trap\n        _this.updatePreviousElement();\n        return _this;\n    }\n    /**\n   * Gets the configured document.\n   * @returns {Document|undefined} Configured document, falling back to the main\n   *  document, if it exists. During SSR, `undefined` is returned since the\n   *  document doesn't exist.\n   */ _inherits(FocusTrap, _React$Component);\n    return _createClass(FocusTrap, [\n        {\n            key: \"getDocument\",\n            value: function getDocument() {\n                // SSR: careful to check if `document` exists before accessing it as a variable\n                return this.props.focusTrapOptions.document || (typeof document !== \"undefined\" ? document : undefined);\n            }\n        },\n        {\n            key: \"getReturnFocusNode\",\n            value: function getReturnFocusNode() {\n                var node = this.getNodeForOption(\"setReturnFocus\", this.previouslyFocusedElement);\n                return node ? node : node === false ? false : this.previouslyFocusedElement;\n            }\n        },\n        {\n            key: \"updatePreviousElement\",\n            value: function updatePreviousElement() {\n                var currentDocument = this.getDocument();\n                if (currentDocument) {\n                    this.previouslyFocusedElement = currentDocument.activeElement;\n                }\n            }\n        },\n        {\n            key: \"deactivateTrap\",\n            value: function deactivateTrap() {\n                // NOTE: it's possible the focus trap has already been deactivated without our knowing it,\n                //  especially if the user set the `clickOutsideDeactivates: true` option on the trap,\n                //  and the mouse was clicked on some element outside the trap; at that point, focus-trap\n                //  will initiate its auto-deactivation process, which will call our own\n                //  handleDeactivate(), which will call into this method\n                if (!this.focusTrap || !this.focusTrap.active) {\n                    return;\n                }\n                this.focusTrap.deactivate({\n                    // NOTE: we never let the trap return the focus since we do that ourselves\n                    returnFocus: false,\n                    // we'll call this in our own post deactivate handler so make sure the trap doesn't\n                    //  do it prematurely\n                    checkCanReturnFocus: null,\n                    // let it call the user's original deactivate handler, if any, instead of\n                    //  our own which calls back into this function\n                    onDeactivate: this.originalOptions.onDeactivate\n                });\n            }\n        },\n        {\n            key: \"handleClickOutsideDeactivates\",\n            value: function handleClickOutsideDeactivates(event) {\n                // use consumer's option (or call their handler) as the permission or denial\n                var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === \"function\" ? this.originalOptions.clickOutsideDeactivates.call(null, event) // call out of context\n                 : this.originalOptions.clickOutsideDeactivates; // boolean\n                if (allowDeactivation) {\n                    // capture the outside target that was clicked so we can use it in the deactivation\n                    //  process since the consumer allowed it to cause auto-deactivation\n                    this.outsideClick = {\n                        target: event.target,\n                        allowDeactivation: allowDeactivation\n                    };\n                }\n                return allowDeactivation;\n            }\n        },\n        {\n            key: \"handleDeactivate\",\n            value: function handleDeactivate() {\n                if (this.originalOptions.onDeactivate) {\n                    this.originalOptions.onDeactivate.call(null); // call user's handler out of context\n                }\n                this.deactivateTrap();\n            }\n        },\n        {\n            key: \"handlePostDeactivate\",\n            value: function handlePostDeactivate() {\n                var _this2 = this;\n                var finishDeactivation = function finishDeactivation() {\n                    var returnFocusNode = _this2.getReturnFocusNode();\n                    var canReturnFocus = !!// did the consumer allow it?\n                    (_this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?\n                    returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && // was there an outside click that allowed deactivation?\n                    (!_this2.outsideClick || // did the consumer allow deactivation when the outside node was clicked?\n                    _this2.outsideClick.allowDeactivation && // is the outside node NOT focusable (implying that it did NOT receive focus\n                    //  as a result of the click-through) -- in which case do NOT restore focus\n                    //  to `returnFocusNode` because focus should remain on the outside node\n                    !isFocusable(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions)));\n                    var _this2$internalOption = _this2.internalOptions.preventScroll, preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;\n                    if (canReturnFocus) {\n                        // return focus to the element that had focus when the trap was activated\n                        returnFocusNode.focus({\n                            preventScroll: preventScroll\n                        });\n                    }\n                    if (_this2.originalOptions.onPostDeactivate) {\n                        _this2.originalOptions.onPostDeactivate.call(null); // don't call it in context of \"this\"\n                    }\n                    _this2.outsideClick = null; // reset: no longer needed\n                };\n                if (this.originalOptions.checkCanReturnFocus) {\n                    this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()) // call out of context\n                    .then(finishDeactivation, finishDeactivation);\n                } else {\n                    finishDeactivation();\n                }\n            }\n        },\n        {\n            key: \"setupFocusTrap\",\n            value: function setupFocusTrap() {\n                if (this.focusTrap) {\n                    // trap already exists: it's possible we're in StrictMode and we're being remounted,\n                    //  in which case, we will have deactivated the trap when we got unmounted (remember,\n                    //  StrictMode, in development, purposely unmounts and remounts components after\n                    //  mounting them the first time to make sure they have reusable state,\n                    //  @see https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state) so now\n                    //  we need to restore the state of the trap according to our component state\n                    // NOTE: Strict mode __violates__ assumptions about the `componentWillUnmount()` API\n                    //  which clearly states -- even for React 18 -- that, \"Once a component instance is\n                    //  unmounted, __it will never be mounted again.__\" (emphasis ours). So when we get\n                    //  unmounted, we assume we're gone forever and we deactivate the trap. But then\n                    //  we get remounted and we're supposed to restore state. But if you had paused,\n                    //  we've now deactivated (we don't know we're amount to get remounted again)\n                    //  which means we need to reactivate and then pause. Otherwise, do nothing.\n                    if (this.props.active && !this.focusTrap.active) {\n                        this.focusTrap.activate();\n                        if (this.props.paused) {\n                            this.focusTrap.pause();\n                        }\n                    }\n                } else {\n                    var nodesExist = this.focusTrapElements.some(Boolean);\n                    if (nodesExist) {\n                        // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n                        this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions);\n                        if (this.props.active) {\n                            this.focusTrap.activate();\n                        }\n                        if (this.props.paused) {\n                            this.focusTrap.pause();\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                if (this.props.active) {\n                    this.setupFocusTrap();\n                }\n            // else, wait for later activation in case the `focusTrapOptions` will be updated\n            //  again before the trap is activated (e.g. if waiting to know what the document\n            //  object will be, so the Trap must be rendered, but the consumer is waiting to\n            //  activate until they have obtained the document from a ref)\n            //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate(prevProps) {\n                if (this.focusTrap) {\n                    if (prevProps.containerElements !== this.props.containerElements) {\n                        this.focusTrap.updateContainerElements(this.props.containerElements);\n                    }\n                    var hasActivated = !prevProps.active && this.props.active;\n                    var hasDeactivated = prevProps.active && !this.props.active;\n                    var hasPaused = !prevProps.paused && this.props.paused;\n                    var hasUnpaused = prevProps.paused && !this.props.paused;\n                    if (hasActivated) {\n                        this.updatePreviousElement();\n                        this.focusTrap.activate();\n                    }\n                    if (hasDeactivated) {\n                        this.deactivateTrap();\n                        return; // un/pause does nothing on an inactive trap\n                    }\n                    if (hasPaused) {\n                        this.focusTrap.pause();\n                    }\n                    if (hasUnpaused) {\n                        this.focusTrap.unpause();\n                    }\n                } else {\n                    // NOTE: if we're in `componentDidUpdate` and we don't have a trap yet,\n                    //  it either means it shouldn't be active, or it should be but none of\n                    //  of given `containerElements` were present in the DOM the last time\n                    //  we tried to create the trap\n                    if (prevProps.containerElements !== this.props.containerElements) {\n                        this.focusTrapElements = this.props.containerElements;\n                    }\n                    // don't create the trap unless it should be active in case the consumer\n                    //  is still updating `focusTrapOptions`\n                    //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n                    if (this.props.active) {\n                        this.updatePreviousElement();\n                        this.setupFocusTrap();\n                    }\n                }\n            }\n        },\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                this.deactivateTrap();\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this3 = this;\n                var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n                if (child) {\n                    if (child.type && child.type === React.Fragment) {\n                        throw new Error(\"A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.\");\n                    }\n                    var callbackRef = function callbackRef(element) {\n                        var containerElements = _this3.props.containerElements;\n                        if (child) {\n                            if (typeof child.ref === \"function\") {\n                                child.ref(element);\n                            } else if (child.ref) {\n                                child.ref.current = element;\n                            }\n                        }\n                        _this3.focusTrapElements = containerElements ? containerElements : [\n                            element\n                        ];\n                    };\n                    var childWithRef = React.cloneElement(child, {\n                        ref: callbackRef\n                    });\n                    return childWithRef;\n                }\n                return null;\n            }\n        }\n    ]);\n}(React.Component); // support server-side rendering where `Element` will not be defined\nvar ElementType = typeof Element === \"undefined\" ? Function : Element;\nFocusTrap.propTypes = {\n    active: PropTypes.bool,\n    paused: PropTypes.bool,\n    focusTrapOptions: PropTypes.shape({\n        document: PropTypes.object,\n        onActivate: PropTypes.func,\n        onPostActivate: PropTypes.func,\n        checkCanFocusTrap: PropTypes.func,\n        onPause: PropTypes.func,\n        onPostPause: PropTypes.func,\n        onUnpause: PropTypes.func,\n        onPostUnpause: PropTypes.func,\n        onDeactivate: PropTypes.func,\n        onPostDeactivate: PropTypes.func,\n        checkCanReturnFocus: PropTypes.func,\n        initialFocus: PropTypes.oneOfType([\n            PropTypes.instanceOf(ElementType),\n            PropTypes.string,\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        fallbackFocus: PropTypes.oneOfType([\n            PropTypes.instanceOf(ElementType),\n            PropTypes.string,\n            // NOTE: does not support `false` as value (or return value from function)\n            PropTypes.func\n        ]),\n        escapeDeactivates: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        clickOutsideDeactivates: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        returnFocusOnDeactivate: PropTypes.bool,\n        setReturnFocus: PropTypes.oneOfType([\n            PropTypes.instanceOf(ElementType),\n            PropTypes.string,\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        allowOutsideClick: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        preventScroll: PropTypes.bool,\n        tabbableOptions: PropTypes.shape({\n            displayCheck: PropTypes.oneOf([\n                \"full\",\n                \"legacy-full\",\n                \"non-zero-area\",\n                \"none\"\n            ]),\n            getShadowRoot: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.func\n            ])\n        }),\n        trapStack: PropTypes.array,\n        isKeyForward: PropTypes.func,\n        isKeyBackward: PropTypes.func\n    }),\n    containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n    // DOM element ONLY\n    children: PropTypes.oneOfType([\n        PropTypes.element,\n        // React element\n        PropTypes.instanceOf(ElementType) // DOM element\n    ])\n};\nFocusTrap.defaultProps = {\n    active: true,\n    paused: false,\n    focusTrapOptions: {},\n    _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC1yZWFjdC9kaXN0L2ZvY3VzLXRyYXAtcmVhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssZ0JBQWdCQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJLENBQUVELENBQUFBLGFBQWFDLENBQUFBLEdBQUksTUFBTSxJQUFJQyxVQUFVO0FBQXNDO0FBQ2xILFNBQVNDLGtCQUFrQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELEVBQUVFLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlaLElBQUlXLENBQUMsQ0FBQ0MsRUFBRTtRQUFFWixFQUFFYyxVQUFVLEdBQUdkLEVBQUVjLFVBQVUsSUFBSSxDQUFDLEdBQUdkLEVBQUVlLFlBQVksR0FBRyxDQUFDLEdBQUcsV0FBV2YsS0FBTUEsQ0FBQUEsRUFBRWdCLFFBQVEsR0FBRyxDQUFDLElBQUlDLE9BQU9DLGNBQWMsQ0FBQ1IsR0FBR1MsZUFBZW5CLEVBQUVvQixHQUFHLEdBQUdwQjtJQUFJO0FBQUU7QUFDdk8sU0FBU3FCLGFBQWFYLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksT0FBT0QsS0FBS0Ysa0JBQWtCQyxFQUFFTixTQUFTLEVBQUVPLElBQUlDLEtBQUtILGtCQUFrQkMsR0FBR0UsSUFBSUssT0FBT0MsY0FBYyxDQUFDUixHQUFHLGFBQWE7UUFB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cmNlcyI6WyJ3ZWJwYWNrOi8vam9iLXBpbG90Ly4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAtcmVhY3QvZGlzdC9mb2N1cy10cmFwLXJlYWN0LmpzP2M5MjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBfZ2V0UHJvdG90eXBlT2YodCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7IHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2ZvY3VzLXRyYXAnKSxcbiAgY3JlYXRlRm9jdXNUcmFwID0gX3JlcXVpcmUuY3JlYXRlRm9jdXNUcmFwO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3RhYmJhYmxlJyksXG4gIGlzRm9jdXNhYmxlID0gX3JlcXVpcmUyLmlzRm9jdXNhYmxlO1xudmFyIEZvY3VzVHJhcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBGb2N1c1RyYXAocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvY3VzVHJhcCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEZvY3VzVHJhcCwgW3Byb3BzXSk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIG9wdGlvbiwgd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb3B0aW9uIHRoYXRcbiAgICAgKiAgY2FuIGJlIGVpdGhlciBhIERPTSBub2RlLCBhIHN0cmluZyB0aGF0IGlzIGEgc2VsZWN0b3IgdG8gZ2V0IGEgbm9kZSwgYGZhbHNlYFxuICAgICAqICAoaWYgYSBub2RlIGlzIGV4cGxpY2l0bHkgTk9UIGdpdmVuKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW55IG9mIHRoZXNlXG4gICAgICogIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWQgfCBmYWxzZSB8IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gUmV0dXJuc1xuICAgICAqICBgdW5kZWZpbmVkYCBpZiB0aGUgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQ7IGBmYWxzZWAgaWYgdGhlIG9wdGlvblxuICAgICAqICByZXNvbHZlZCB0byBgZmFsc2VgIChub2RlIGV4cGxpY2l0bHkgbm90IGdpdmVuKTsgb3RoZXJ3aXNlLCB0aGUgcmVzb2x2ZWRcbiAgICAgKiAgRE9NIG5vZGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBvcHRpb24gaXMgc2V0LCBub3QgYGZhbHNlYCwgYW5kIGlzIG5vdCwgb3IgZG9lcyBub3RcbiAgICAgKiAgcmVzb2x2ZSB0byBhIG5vZGUuXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImdldE5vZGVGb3JPcHRpb25cIiwgZnVuY3Rpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAgIHZhciBfdGhpcyRpbnRlcm5hbE9wdGlvbnM7XG4gICAgICAvLyB1c2UgaW50ZXJuYWwgb3B0aW9ucyBmaXJzdCwgZmFsbGluZyBiYWNrIHRvIG9yaWdpbmFsIG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25WYWx1ZSA9IChfdGhpcyRpbnRlcm5hbE9wdGlvbnMgPSB0aGlzLmludGVybmFsT3B0aW9uc1tvcHRpb25OYW1lXSkgIT09IG51bGwgJiYgX3RoaXMkaW50ZXJuYWxPcHRpb25zICE9PSB2b2lkIDAgPyBfdGhpcyRpbnRlcm5hbE9wdGlvbnMgOiB0aGlzLm9yaWdpbmFsT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25WYWx1ZSA9IG9wdGlvblZhbHVlLmFwcGx5KHZvaWQgMCwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25WYWx1ZSA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdmFsdWVcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9uVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UsIGVtcHR5IHN0cmluZyAoaW52YWxpZCksIG51bGwgKGludmFsaWQpLCAwIChpbnZhbGlkKVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIHdhcyBzcGVjaWZpZWQgYnV0IHdhcyBub3QgYSBub2RlLCBvciBkaWQgbm90IHJldHVybiBhIG5vZGVcIikpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTsgLy8gY291bGQgYmUgSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQsIG9yIG5vbi1lbXB0eSBzdHJpbmcgYXQgdGhpcyBwb2ludFxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgX3RoaXMkZ2V0RG9jdW1lbnQ7XG4gICAgICAgIG5vZGUgPSAoX3RoaXMkZ2V0RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KCkpID09PSBudWxsIHx8IF90aGlzJGdldERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXREb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTsgLy8gcmVzb2x2ZSB0byBub2RlLCBvciBudWxsIGlmIGZhaWxzXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIGFzIHNlbGVjdG9yIHJlZmVycyB0byBubyBrbm93biBub2RlXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgX3RoaXMuaGFuZGxlRGVhY3RpdmF0ZSA9IF90aGlzLmhhbmRsZURlYWN0aXZhdGUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlUG9zdERlYWN0aXZhdGUgPSBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlcyA9IF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLmJpbmQoX3RoaXMpO1xuXG4gICAgLy8gZm9jdXMtdHJhcCBvcHRpb25zIHVzZWQgaW50ZXJuYWxseSB3aGVuIGNyZWF0aW5nIHRoZSB0cmFwXG4gICAgX3RoaXMuaW50ZXJuYWxPcHRpb25zID0ge1xuICAgICAgLy8gV2UgbmVlZCB0byBoaWphY2sgdGhlIHJldHVybkZvY3VzT25EZWFjdGl2YXRlIG9wdGlvbixcbiAgICAgIC8vIGJlY2F1c2UgUmVhY3QgY2FuIG1vdmUgZm9jdXMgaW50byB0aGUgZWxlbWVudCBiZWZvcmUgd2UgYXJyaXZlZCBhdFxuICAgICAgLy8gdGhpcyBsaWZlY3ljbGUgaG9vayAoZS5nLiB3aXRoIGF1dG9Gb2N1cyBpbnB1dHMpLiBTbyB0aGUgY29tcG9uZW50XG4gICAgICAvLyBjYXB0dXJlcyB0aGUgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50IGluIGNvbXBvbmVudFdpbGxNb3VudCxcbiAgICAgIC8vIHRoZW4gKG9wdGlvbmFsbHkpIHJldHVybnMgZm9jdXMgdG8gaXQgaW4gY29tcG9uZW50V2lsbFVubW91bnQuXG4gICAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogZmFsc2UsXG4gICAgICAvLyB0aGUgcmVzdCBvZiB0aGVzZSBhcmUgYWxzbyByZWxhdGVkIHRvIGRlYWN0aXZhdGlvbiBvZiB0aGUgdHJhcCwgYW5kIHdlXG4gICAgICAvLyAgbmVlZCB0byB1c2UgdGhlbSBhbmQgY29udHJvbCB0aGVtIGFzIHdlbGxcbiAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IG51bGwsXG4gICAgICBvbkRlYWN0aXZhdGU6IF90aGlzLmhhbmRsZURlYWN0aXZhdGUsXG4gICAgICBvblBvc3REZWFjdGl2YXRlOiBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZSxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIHRoaXMgc2V0dGluZyBhcyB3ZWxsIHNvIHRoYXQgd2UgY2FuIGtub3cgaWYgd2Ugc2hvdWxkXG4gICAgICAvLyAgTk9UIHJldHVybiBmb2N1cyBpZiB0aGUgdHJhcCBnZXRzIGF1dG8tZGVhY3RpdmF0ZWQgYXMgdGhlIHJlc3VsdCBvZiBhblxuICAgICAgLy8gIG91dHNpZGUgY2xpY2sgKG90aGVyd2lzZSwgd2UnbGwgYWx3YXlzIHRoaW5rIHdlIHNob3VsZCByZXR1cm4gZm9jdXMgYmVjYXVzZVxuICAgICAgLy8gIG9mIGhvdyB3ZSBtYW5hZ2UgdGhhdCBmbGFnIGludGVybmFsbHkgaGVyZSlcbiAgICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlc1xuICAgIH07XG5cbiAgICAvLyBvcmlnaW5hbCBvcHRpb25zIHByb3ZpZGVkIGJ5IHRoZSBjb25zdW1lclxuICAgIF90aGlzLm9yaWdpbmFsT3B0aW9ucyA9IHtcbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGFib3ZlIGBpbnRlcm5hbE9wdGlvbnNgLCB3ZSBtYWludGFpbiBvdXIgb3duIGZsYWcgZm9yXG4gICAgICAvLyAgdGhpcyBvcHRpb24sIGFuZCBkZWZhdWx0IGl0IHRvIGB0cnVlYCBiZWNhdXNlIHRoYXQncyBmb2N1cy10cmFwJ3MgZGVmYXVsdFxuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IHRydWUsXG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBhYm92ZSBgaW50ZXJuYWxPcHRpb25zYCwgd2Uga2VlcCB0aGVzZSBzZXBhcmF0ZSBzaW5jZVxuICAgICAgLy8gIHRoZXkncmUgcGFydCBvZiB0aGUgZGVhY3RpdmF0aW9uIHByb2Nlc3Mgd2hpY2ggd2UgY29uZmlndXJlIChpbnRlcm5hbGx5KSB0b1xuICAgICAgLy8gIGJlIHNoYXJlZCBiZXR3ZWVuIGZvY3VzLXRyYXAgYW5kIGZvY3VzLXRyYXAtcmVhY3RcbiAgICAgIG9uRGVhY3RpdmF0ZTogbnVsbCxcbiAgICAgIG9uUG9zdERlYWN0aXZhdGU6IG51bGwsXG4gICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgLy8gdGhlIHVzZXIncyBzZXR0aW5nLCBkZWZhdWx0ZWQgdG8gZmFsc2Ugc2luY2UgZm9jdXMtdHJhcCBkZWZhdWx0cyB0aGlzIHRvIGZhbHNlXG4gICAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogZmFsc2VcbiAgICB9O1xuICAgIHZhciBmb2N1c1RyYXBPcHRpb25zID0gcHJvcHMuZm9jdXNUcmFwT3B0aW9ucztcbiAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIGZvY3VzVHJhcE9wdGlvbnMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvY3VzVHJhcE9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ29uRGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ29uUG9zdERlYWN0aXZhdGUnIHx8IG9wdGlvbk5hbWUgPT09ICdjaGVja0NhblJldHVybkZvY3VzJyB8fCBvcHRpb25OYW1lID09PSAnY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMnKSB7XG4gICAgICAgIF90aGlzLm9yaWdpbmFsT3B0aW9uc1tvcHRpb25OYW1lXSA9IGZvY3VzVHJhcE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIGNvbnRpbnVlOyAvLyBleGNsdWRlIGZyb20gaW50ZXJuYWxPcHRpb25zXG4gICAgICB9XG4gICAgICBfdGhpcy5pbnRlcm5hbE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBmb2N1c1RyYXBPcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIH1cblxuICAgIC8vIGlmIHNldCwgYHsgdGFyZ2V0OiBOb2RlLCBhbGxvd0RlYWN0aXZhdGlvbjogYm9vbGVhbiB9YCB3aGVyZSBgdGFyZ2V0YCBpcyB0aGUgb3V0c2lkZVxuICAgIC8vICBub2RlIHRoYXQgd2FzIGNsaWNrZWQsIGFuZCBgYWxsb3dEZWFjdGl2YXRpb25gIGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvbnN1bWVyJ3NcbiAgICAvLyAgb3B0aW9uIChzdG9yZWQgaW4gYHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzYCwgd2hpY2ggbWF5IGJlIGFcbiAgICAvLyAgZnVuY3Rpb24pIHdoZXRoZXIgdG8gYWxsb3cgb3IgZGVueSBhdXRvLWRlYWN0aXZhdGlvbiBvbiBjbGljayBvbiB0aGlzIG91dHNpZGUgbm9kZVxuICAgIF90aGlzLm91dHNpZGVDbGljayA9IG51bGw7XG5cbiAgICAvLyBlbGVtZW50cyBmcm9tIHdoaWNoIHRvIGNyZWF0ZSB0aGUgZm9jdXMgdHJhcCBvbiBtb3VudDsgaWYgYSBjaGlsZCBpcyB1c2VkXG4gICAgLy8gIGluc3RlYWQgb2YgdGhlIGBjb250YWluZXJFbGVtZW50c2AgcHJvcCwgd2UnbGwgZ2V0IHRoZSBjaGlsZCdzIHJlbGF0ZWRcbiAgICAvLyAgZWxlbWVudCB3aGVuIHRoZSB0cmFwIHJlbmRlcnMgYW5kIHRoZW4gaXMgZGVjbGFyZWQgJ21vdW50ZWQnXG4gICAgX3RoaXMuZm9jdXNUcmFwRWxlbWVudHMgPSBwcm9wcy5jb250YWluZXJFbGVtZW50cyB8fCBbXTtcblxuICAgIC8vIG5vdyB3ZSByZW1lbWJlciB3aGF0IHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IGlzLCBub3QgcmVseWluZyBvbiBmb2N1cy10cmFwXG4gICAgX3RoaXMudXBkYXRlUHJldmlvdXNFbGVtZW50KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbmZpZ3VyZWQgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudHx1bmRlZmluZWR9IENvbmZpZ3VyZWQgZG9jdW1lbnQsIGZhbGxpbmcgYmFjayB0byB0aGUgbWFpblxuICAgKiAgZG9jdW1lbnQsIGlmIGl0IGV4aXN0cy4gRHVyaW5nIFNTUiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgc2luY2UgdGhlXG4gICAqICBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgX2luaGVyaXRzKEZvY3VzVHJhcCwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRm9jdXNUcmFwLCBbe1xuICAgIGtleTogXCJnZXREb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICAgIC8vIFNTUjogY2FyZWZ1bCB0byBjaGVjayBpZiBgZG9jdW1lbnRgIGV4aXN0cyBiZWZvcmUgYWNjZXNzaW5nIGl0IGFzIGEgdmFyaWFibGVcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmZvY3VzVHJhcE9wdGlvbnMuZG9jdW1lbnQgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJldHVybkZvY3VzTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUoKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUZvck9wdGlvbignc2V0UmV0dXJuRm9jdXMnLCB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICByZXR1cm4gbm9kZSA/IG5vZGUgOiBub2RlID09PSBmYWxzZSA/IGZhbHNlIDogdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQgd2l0aCB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudC4gKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcmV2aW91c0VsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUHJldmlvdXNFbGVtZW50KCkge1xuICAgICAgdmFyIGN1cnJlbnREb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50RG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBjdXJyZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhY3RpdmF0ZVRyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVhY3RpdmF0ZVRyYXAoKSB7XG4gICAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIHRoZSBmb2N1cyB0cmFwIGhhcyBhbHJlYWR5IGJlZW4gZGVhY3RpdmF0ZWQgd2l0aG91dCBvdXIga25vd2luZyBpdCxcbiAgICAgIC8vICBlc3BlY2lhbGx5IGlmIHRoZSB1c2VyIHNldCB0aGUgYGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiB0cnVlYCBvcHRpb24gb24gdGhlIHRyYXAsXG4gICAgICAvLyAgYW5kIHRoZSBtb3VzZSB3YXMgY2xpY2tlZCBvbiBzb21lIGVsZW1lbnQgb3V0c2lkZSB0aGUgdHJhcDsgYXQgdGhhdCBwb2ludCwgZm9jdXMtdHJhcFxuICAgICAgLy8gIHdpbGwgaW5pdGlhdGUgaXRzIGF1dG8tZGVhY3RpdmF0aW9uIHByb2Nlc3MsIHdoaWNoIHdpbGwgY2FsbCBvdXIgb3duXG4gICAgICAvLyAgaGFuZGxlRGVhY3RpdmF0ZSgpLCB3aGljaCB3aWxsIGNhbGwgaW50byB0aGlzIG1ldGhvZFxuICAgICAgaWYgKCF0aGlzLmZvY3VzVHJhcCB8fCAhdGhpcy5mb2N1c1RyYXAuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoe1xuICAgICAgICAvLyBOT1RFOiB3ZSBuZXZlciBsZXQgdGhlIHRyYXAgcmV0dXJuIHRoZSBmb2N1cyBzaW5jZSB3ZSBkbyB0aGF0IG91cnNlbHZlc1xuICAgICAgICByZXR1cm5Gb2N1czogZmFsc2UsXG4gICAgICAgIC8vIHdlJ2xsIGNhbGwgdGhpcyBpbiBvdXIgb3duIHBvc3QgZGVhY3RpdmF0ZSBoYW5kbGVyIHNvIG1ha2Ugc3VyZSB0aGUgdHJhcCBkb2Vzbid0XG4gICAgICAgIC8vICBkbyBpdCBwcmVtYXR1cmVseVxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgICAvLyBsZXQgaXQgY2FsbCB0aGUgdXNlcidzIG9yaWdpbmFsIGRlYWN0aXZhdGUgaGFuZGxlciwgaWYgYW55LCBpbnN0ZWFkIG9mXG4gICAgICAgIC8vICBvdXIgb3duIHdoaWNoIGNhbGxzIGJhY2sgaW50byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIG9uRGVhY3RpdmF0ZTogdGhpcy5vcmlnaW5hbE9wdGlvbnMub25EZWFjdGl2YXRlXG4gICAgICAgIC8vIE5PVEU6IGZvciBwb3N0IGRlYWN0aXZhdGUsIGRvbid0IHNwZWNpZnkgYW55dGhpbmcgc28gdGhhdCBpdCBjYWxscyB0aGVcbiAgICAgICAgLy8gIG9uUG9zdERlYWN0aXZhdGUgaGFuZGxlciBzcGVjaWZpZWQgb24gYHRoaXMuaW50ZXJuYWxPcHRpb25zYFxuICAgICAgICAvLyAgd2hpY2ggd2lsbCBhbHdheXMgYmUgb3VyIG93biBgaGFuZGxlUG9zdERlYWN0aXZhdGUoKWAgaGFuZGxlciwgd2hpY2hcbiAgICAgICAgLy8gIHdpbGwgZmluaXNoIHRoaW5ncyBvZmYgYnkgY2FsbGluZyB0aGUgdXNlcidzIHByb3ZpZGVkIG9uUG9zdERlYWN0aXZhdGVcbiAgICAgICAgLy8gIGhhbmRsZXIsIGlmIGFueSwgYXQgdGhlIHJpZ2h0IHRpbWVcbiAgICAgICAgLy8gb25Qb3N0RGVhY3RpdmF0ZTogTk9USElOR1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKGV2ZW50KSB7XG4gICAgICAvLyB1c2UgY29uc3VtZXIncyBvcHRpb24gKG9yIGNhbGwgdGhlaXIgaGFuZGxlcikgYXMgdGhlIHBlcm1pc3Npb24gb3IgZGVuaWFsXG4gICAgICB2YXIgYWxsb3dEZWFjdGl2YXRpb24gPSB0eXBlb2YgdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlcy5jYWxsKG51bGwsIGV2ZW50KSAvLyBjYWxsIG91dCBvZiBjb250ZXh0XG4gICAgICA6IHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOyAvLyBib29sZWFuXG5cbiAgICAgIGlmIChhbGxvd0RlYWN0aXZhdGlvbikge1xuICAgICAgICAvLyBjYXB0dXJlIHRoZSBvdXRzaWRlIHRhcmdldCB0aGF0IHdhcyBjbGlja2VkIHNvIHdlIGNhbiB1c2UgaXQgaW4gdGhlIGRlYWN0aXZhdGlvblxuICAgICAgICAvLyAgcHJvY2VzcyBzaW5jZSB0aGUgY29uc3VtZXIgYWxsb3dlZCBpdCB0byBjYXVzZSBhdXRvLWRlYWN0aXZhdGlvblxuICAgICAgICB0aGlzLm91dHNpZGVDbGljayA9IHtcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBhbGxvd0RlYWN0aXZhdGlvbjogYWxsb3dEZWFjdGl2YXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxvd0RlYWN0aXZhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRGVhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEZWFjdGl2YXRlKCkge1xuICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsT3B0aW9ucy5vbkRlYWN0aXZhdGUuY2FsbChudWxsKTsgLy8gY2FsbCB1c2VyJ3MgaGFuZGxlciBvdXQgb2YgY29udGV4dFxuICAgICAgfVxuICAgICAgdGhpcy5kZWFjdGl2YXRlVHJhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVQb3N0RGVhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQb3N0RGVhY3RpdmF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGZpbmlzaERlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIGZpbmlzaERlYWN0aXZhdGlvbigpIHtcbiAgICAgICAgdmFyIHJldHVybkZvY3VzTm9kZSA9IF90aGlzMi5nZXRSZXR1cm5Gb2N1c05vZGUoKTtcbiAgICAgICAgdmFyIGNhblJldHVybkZvY3VzID0gISEoXG4gICAgICAgIC8vIGRpZCB0aGUgY29uc3VtZXIgYWxsb3cgaXQ/XG5cbiAgICAgICAgX3RoaXMyLm9yaWdpbmFsT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAmJiAvLyBjYW4gd2UgYWN0dWFsbHkgZm9jdXMgdGhlIG5vZGU/XG4gICAgICAgIHJldHVybkZvY3VzTm9kZSAhPT0gbnVsbCAmJiByZXR1cm5Gb2N1c05vZGUgIT09IHZvaWQgMCAmJiByZXR1cm5Gb2N1c05vZGUuZm9jdXMgJiYgKFxuICAgICAgICAvLyB3YXMgdGhlcmUgYW4gb3V0c2lkZSBjbGljayB0aGF0IGFsbG93ZWQgZGVhY3RpdmF0aW9uP1xuICAgICAgICAhX3RoaXMyLm91dHNpZGVDbGljayB8fFxuICAgICAgICAvLyBkaWQgdGhlIGNvbnN1bWVyIGFsbG93IGRlYWN0aXZhdGlvbiB3aGVuIHRoZSBvdXRzaWRlIG5vZGUgd2FzIGNsaWNrZWQ/XG4gICAgICAgIF90aGlzMi5vdXRzaWRlQ2xpY2suYWxsb3dEZWFjdGl2YXRpb24gJiZcbiAgICAgICAgLy8gaXMgdGhlIG91dHNpZGUgbm9kZSBOT1QgZm9jdXNhYmxlIChpbXBseWluZyB0aGF0IGl0IGRpZCBOT1QgcmVjZWl2ZSBmb2N1c1xuICAgICAgICAvLyAgYXMgYSByZXN1bHQgb2YgdGhlIGNsaWNrLXRocm91Z2gpIC0tIGluIHdoaWNoIGNhc2UgZG8gTk9UIHJlc3RvcmUgZm9jdXNcbiAgICAgICAgLy8gIHRvIGByZXR1cm5Gb2N1c05vZGVgIGJlY2F1c2UgZm9jdXMgc2hvdWxkIHJlbWFpbiBvbiB0aGUgb3V0c2lkZSBub2RlXG4gICAgICAgICFpc0ZvY3VzYWJsZShfdGhpczIub3V0c2lkZUNsaWNrLnRhcmdldCwgX3RoaXMyLmludGVybmFsT3B0aW9ucy50YWJiYWJsZU9wdGlvbnMpKVxuXG4gICAgICAgIC8vIGlmIG5vLCB0aGUgcmVzdG9yZSBmb2N1cyB0byBgcmV0dXJuRm9jdXNOb2RlYCBhdCB0aGlzIHBvaW50XG4gICAgICAgICk7XG4gICAgICAgIHZhciBfdGhpczIkaW50ZXJuYWxPcHRpb24gPSBfdGhpczIuaW50ZXJuYWxPcHRpb25zLnByZXZlbnRTY3JvbGwsXG4gICAgICAgICAgcHJldmVudFNjcm9sbCA9IF90aGlzMiRpbnRlcm5hbE9wdGlvbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfdGhpczIkaW50ZXJuYWxPcHRpb247XG4gICAgICAgIGlmIChjYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICAgIC8vIHJldHVybiBmb2N1cyB0byB0aGUgZWxlbWVudCB0aGF0IGhhZCBmb2N1cyB3aGVuIHRoZSB0cmFwIHdhcyBhY3RpdmF0ZWRcbiAgICAgICAgICByZXR1cm5Gb2N1c05vZGUuZm9jdXMoe1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbDogcHJldmVudFNjcm9sbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIub3JpZ2luYWxPcHRpb25zLm9uUG9zdERlYWN0aXZhdGUpIHtcbiAgICAgICAgICBfdGhpczIub3JpZ2luYWxPcHRpb25zLm9uUG9zdERlYWN0aXZhdGUuY2FsbChudWxsKTsgLy8gZG9uJ3QgY2FsbCBpdCBpbiBjb250ZXh0IG9mIFwidGhpc1wiXG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLm91dHNpZGVDbGljayA9IG51bGw7IC8vIHJlc2V0OiBubyBsb25nZXIgbmVlZGVkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcHRpb25zLmNoZWNrQ2FuUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2hlY2tDYW5SZXR1cm5Gb2N1cy5jYWxsKG51bGwsIHRoaXMuZ2V0UmV0dXJuRm9jdXNOb2RlKCkpIC8vIGNhbGwgb3V0IG9mIGNvbnRleHRcbiAgICAgICAgLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoRGVhY3RpdmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwRm9jdXNUcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwRm9jdXNUcmFwKCkge1xuICAgICAgaWYgKHRoaXMuZm9jdXNUcmFwKSB7XG4gICAgICAgIC8vIHRyYXAgYWxyZWFkeSBleGlzdHM6IGl0J3MgcG9zc2libGUgd2UncmUgaW4gU3RyaWN0TW9kZSBhbmQgd2UncmUgYmVpbmcgcmVtb3VudGVkLFxuICAgICAgICAvLyAgaW4gd2hpY2ggY2FzZSwgd2Ugd2lsbCBoYXZlIGRlYWN0aXZhdGVkIHRoZSB0cmFwIHdoZW4gd2UgZ290IHVubW91bnRlZCAocmVtZW1iZXIsXG4gICAgICAgIC8vICBTdHJpY3RNb2RlLCBpbiBkZXZlbG9wbWVudCwgcHVycG9zZWx5IHVubW91bnRzIGFuZCByZW1vdW50cyBjb21wb25lbnRzIGFmdGVyXG4gICAgICAgIC8vICBtb3VudGluZyB0aGVtIHRoZSBmaXJzdCB0aW1lIHRvIG1ha2Ugc3VyZSB0aGV5IGhhdmUgcmV1c2FibGUgc3RhdGUsXG4gICAgICAgIC8vICBAc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9zdHJpY3QtbW9kZS5odG1sI2Vuc3VyaW5nLXJldXNhYmxlLXN0YXRlKSBzbyBub3dcbiAgICAgICAgLy8gIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIHRyYXAgYWNjb3JkaW5nIHRvIG91ciBjb21wb25lbnQgc3RhdGVcbiAgICAgICAgLy8gTk9URTogU3RyaWN0IG1vZGUgX192aW9sYXRlc19fIGFzc3VtcHRpb25zIGFib3V0IHRoZSBgY29tcG9uZW50V2lsbFVubW91bnQoKWAgQVBJXG4gICAgICAgIC8vICB3aGljaCBjbGVhcmx5IHN0YXRlcyAtLSBldmVuIGZvciBSZWFjdCAxOCAtLSB0aGF0LCBcIk9uY2UgYSBjb21wb25lbnQgaW5zdGFuY2UgaXNcbiAgICAgICAgLy8gIHVubW91bnRlZCwgX19pdCB3aWxsIG5ldmVyIGJlIG1vdW50ZWQgYWdhaW4uX19cIiAoZW1waGFzaXMgb3VycykuIFNvIHdoZW4gd2UgZ2V0XG4gICAgICAgIC8vICB1bm1vdW50ZWQsIHdlIGFzc3VtZSB3ZSdyZSBnb25lIGZvcmV2ZXIgYW5kIHdlIGRlYWN0aXZhdGUgdGhlIHRyYXAuIEJ1dCB0aGVuXG4gICAgICAgIC8vICB3ZSBnZXQgcmVtb3VudGVkIGFuZCB3ZSdyZSBzdXBwb3NlZCB0byByZXN0b3JlIHN0YXRlLiBCdXQgaWYgeW91IGhhZCBwYXVzZWQsXG4gICAgICAgIC8vICB3ZSd2ZSBub3cgZGVhY3RpdmF0ZWQgKHdlIGRvbid0IGtub3cgd2UncmUgYW1vdW50IHRvIGdldCByZW1vdW50ZWQgYWdhaW4pXG4gICAgICAgIC8vICB3aGljaCBtZWFucyB3ZSBuZWVkIHRvIHJlYWN0aXZhdGUgYW5kIHRoZW4gcGF1c2UuIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlICYmICF0aGlzLmZvY3VzVHJhcC5hY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAucGF1c2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub2Rlc0V4aXN0ID0gdGhpcy5mb2N1c1RyYXBFbGVtZW50cy5zb21lKEJvb2xlYW4pO1xuICAgICAgICBpZiAobm9kZXNFeGlzdCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcm9wLXR5cGVzIC0tIF9jcmVhdGVGb2N1c1RyYXAgaXMgYW4gaW50ZXJuYWwgcHJvcFxuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwID0gdGhpcy5wcm9wcy5fY3JlYXRlRm9jdXNUcmFwKHRoaXMuZm9jdXNUcmFwRWxlbWVudHMsIHRoaXMuaW50ZXJuYWxPcHRpb25zKTtcbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnByb3BzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAucGF1c2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5zZXR1cEZvY3VzVHJhcCgpO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSwgd2FpdCBmb3IgbGF0ZXIgYWN0aXZhdGlvbiBpbiBjYXNlIHRoZSBgZm9jdXNUcmFwT3B0aW9uc2Agd2lsbCBiZSB1cGRhdGVkXG4gICAgICAvLyAgYWdhaW4gYmVmb3JlIHRoZSB0cmFwIGlzIGFjdGl2YXRlZCAoZS5nLiBpZiB3YWl0aW5nIHRvIGtub3cgd2hhdCB0aGUgZG9jdW1lbnRcbiAgICAgIC8vICBvYmplY3Qgd2lsbCBiZSwgc28gdGhlIFRyYXAgbXVzdCBiZSByZW5kZXJlZCwgYnV0IHRoZSBjb25zdW1lciBpcyB3YWl0aW5nIHRvXG4gICAgICAvLyAgYWN0aXZhdGUgdW50aWwgdGhleSBoYXZlIG9idGFpbmVkIHRoZSBkb2N1bWVudCBmcm9tIGEgcmVmKVxuICAgICAgLy8gIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC1yZWFjdC9pc3N1ZXMvNTM5XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5jb250YWluZXJFbGVtZW50cyAhPT0gdGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cykge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzKHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNBY3RpdmF0ZWQgPSAhcHJldlByb3BzLmFjdGl2ZSAmJiB0aGlzLnByb3BzLmFjdGl2ZTtcbiAgICAgICAgdmFyIGhhc0RlYWN0aXZhdGVkID0gcHJldlByb3BzLmFjdGl2ZSAmJiAhdGhpcy5wcm9wcy5hY3RpdmU7XG4gICAgICAgIHZhciBoYXNQYXVzZWQgPSAhcHJldlByb3BzLnBhdXNlZCAmJiB0aGlzLnByb3BzLnBhdXNlZDtcbiAgICAgICAgdmFyIGhhc1VucGF1c2VkID0gcHJldlByb3BzLnBhdXNlZCAmJiAhdGhpcy5wcm9wcy5wYXVzZWQ7XG4gICAgICAgIGlmIChoYXNBY3RpdmF0ZWQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpb3VzRWxlbWVudCgpO1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgICAgdGhpcy5kZWFjdGl2YXRlVHJhcCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gdW4vcGF1c2UgZG9lcyBub3RoaW5nIG9uIGFuIGluYWN0aXZlIHRyYXBcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVW5wYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC51bnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5PVEU6IGlmIHdlJ3JlIGluIGBjb21wb25lbnREaWRVcGRhdGVgIGFuZCB3ZSBkb24ndCBoYXZlIGEgdHJhcCB5ZXQsXG4gICAgICAgIC8vICBpdCBlaXRoZXIgbWVhbnMgaXQgc2hvdWxkbid0IGJlIGFjdGl2ZSwgb3IgaXQgc2hvdWxkIGJlIGJ1dCBub25lIG9mXG4gICAgICAgIC8vICBvZiBnaXZlbiBgY29udGFpbmVyRWxlbWVudHNgIHdlcmUgcHJlc2VudCBpbiB0aGUgRE9NIHRoZSBsYXN0IHRpbWVcbiAgICAgICAgLy8gIHdlIHRyaWVkIHRvIGNyZWF0ZSB0aGUgdHJhcFxuXG4gICAgICAgIGlmIChwcmV2UHJvcHMuY29udGFpbmVyRWxlbWVudHMgIT09IHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcEVsZW1lbnRzID0gdGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbid0IGNyZWF0ZSB0aGUgdHJhcCB1bmxlc3MgaXQgc2hvdWxkIGJlIGFjdGl2ZSBpbiBjYXNlIHRoZSBjb25zdW1lclxuICAgICAgICAvLyAgaXMgc3RpbGwgdXBkYXRpbmcgYGZvY3VzVHJhcE9wdGlvbnNgXG4gICAgICAgIC8vICBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzUzOVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpb3VzRWxlbWVudCgpO1xuICAgICAgICAgIHRoaXMuc2V0dXBGb2N1c1RyYXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZVRyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5wcm9wcy5jaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZm9jdXMtdHJhcCBjYW5ub3QgdXNlIGEgRnJhZ21lbnQgYXMgaXRzIGNoaWxkIGNvbnRhaW5lci4gVHJ5IHJlcGxhY2luZyBpdCB3aXRoIGEgPGRpdj4gZWxlbWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2tSZWYgPSBmdW5jdGlvbiBjYWxsYmFja1JlZihlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lckVsZW1lbnRzID0gX3RoaXMzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzO1xuICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVmKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5yZWYpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczMuZm9jdXNUcmFwRWxlbWVudHMgPSBjb250YWluZXJFbGVtZW50cyA/IGNvbnRhaW5lckVsZW1lbnRzIDogW2VsZW1lbnRdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hpbGRXaXRoUmVmID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgcmVmOiBjYWxsYmFja1JlZlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkV2l0aFJlZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xufShSZWFjdC5Db21wb25lbnQpOyAvLyBzdXBwb3J0IHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aGVyZSBgRWxlbWVudGAgd2lsbCBub3QgYmUgZGVmaW5lZFxudmFyIEVsZW1lbnRUeXBlID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gRnVuY3Rpb24gOiBFbGVtZW50O1xuRm9jdXNUcmFwLnByb3BUeXBlcyA9IHtcbiAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgcGF1c2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZm9jdXNUcmFwT3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkb2N1bWVudDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbkFjdGl2YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RBY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hlY2tDYW5Gb2N1c1RyYXA6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUGF1c2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUG9zdFBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblVucGF1c2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUG9zdFVucGF1c2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVhY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Qb3N0RGVhY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaW5pdGlhbEZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGZhbGxiYWNrRm9jdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSwgUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvLyBOT1RFOiBkb2VzIG5vdCBzdXBwb3J0IGBmYWxzZWAgYXMgdmFsdWUgKG9yIHJldHVybiB2YWx1ZSBmcm9tIGZ1bmN0aW9uKVxuICAgIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZXNjYXBlRGVhY3RpdmF0ZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2V0UmV0dXJuRm9jdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSwgUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgYWxsb3dPdXRzaWRlQ2xpY2s6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIHByZXZlbnRTY3JvbGw6IFByb3BUeXBlcy5ib29sLFxuICAgIHRhYmJhYmxlT3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGRpc3BsYXlDaGVjazogUHJvcFR5cGVzLm9uZU9mKFsnZnVsbCcsICdsZWdhY3ktZnVsbCcsICdub24temVyby1hcmVhJywgJ25vbmUnXSksXG4gICAgICBnZXRTaGFkb3dSb290OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKVxuICAgIH0pLFxuICAgIHRyYXBTdGFjazogUHJvcFR5cGVzLmFycmF5LFxuICAgIGlzS2V5Rm9yd2FyZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaXNLZXlCYWNrd2FyZDogUHJvcFR5cGVzLmZ1bmNcbiAgfSksXG4gIGNvbnRhaW5lckVsZW1lbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSkpLFxuICAvLyBET00gZWxlbWVudCBPTkxZXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCxcbiAgLy8gUmVhY3QgZWxlbWVudFxuICBQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSkgLy8gRE9NIGVsZW1lbnRcbiAgXSlcblxuICAvLyBOT1RFOiBfY3JlYXRlRm9jdXNUcmFwIGlzIGludGVybmFsLCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LCBzbyB3ZSBkb24ndFxuICAvLyAgc3BlY2lmeSBpdCBoZXJlLiBJdCdzIGV4cGVjdGVkIHRvIGJlIHNldCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbVxuICAvLyAgcmVxdWlyZSgnZm9jdXMtdHJhcCcpLCBvciBvbmUgd2l0aCBhIGNvbXBhdGlibGUgaW50ZXJmYWNlLlxufTtcbkZvY3VzVHJhcC5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZTogdHJ1ZSxcbiAgcGF1c2VkOiBmYWxzZSxcbiAgZm9jdXNUcmFwT3B0aW9uczoge30sXG4gIF9jcmVhdGVGb2N1c1RyYXA6IGNyZWF0ZUZvY3VzVHJhcFxufTtcbm1vZHVsZS5leHBvcnRzID0gRm9jdXNUcmFwOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJhIiwibiIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZSIsInIiLCJ0IiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsImNhbGwiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiYmluZCIsIl9fcHJvdG9fXyIsIl9pbmhlcml0cyIsImNyZWF0ZSIsInZhbHVlIiwiX3NldFByb3RvdHlwZU9mIiwiX2RlZmluZVByb3BlcnR5IiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiUmVhY3QiLCJyZXF1aXJlIiwiUHJvcFR5cGVzIiwiX3JlcXVpcmUiLCJjcmVhdGVGb2N1c1RyYXAiLCJfcmVxdWlyZTIiLCJpc0ZvY3VzYWJsZSIsIkZvY3VzVHJhcCIsIl9SZWFjdCRDb21wb25lbnQiLCJwcm9wcyIsIl90aGlzIiwib3B0aW9uTmFtZSIsIl90aGlzJGludGVybmFsT3B0aW9ucyIsIm9wdGlvblZhbHVlIiwiaW50ZXJuYWxPcHRpb25zIiwib3JpZ2luYWxPcHRpb25zIiwiX2xlbiIsImFyZ3VtZW50cyIsInBhcmFtcyIsIkFycmF5IiwiX2tleSIsInVuZGVmaW5lZCIsIkVycm9yIiwiY29uY2F0Iiwibm9kZSIsIl90aGlzJGdldERvY3VtZW50IiwiZ2V0RG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaGFuZGxlRGVhY3RpdmF0ZSIsImhhbmRsZVBvc3REZWFjdGl2YXRlIiwiaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMiLCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSIsImNoZWNrQ2FuUmV0dXJuRm9jdXMiLCJvbkRlYWN0aXZhdGUiLCJvblBvc3REZWFjdGl2YXRlIiwiY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMiLCJmb2N1c1RyYXBPcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJvdXRzaWRlQ2xpY2siLCJmb2N1c1RyYXBFbGVtZW50cyIsImNvbnRhaW5lckVsZW1lbnRzIiwidXBkYXRlUHJldmlvdXNFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRSZXR1cm5Gb2N1c05vZGUiLCJnZXROb2RlRm9yT3B0aW9uIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiY3VycmVudERvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImRlYWN0aXZhdGVUcmFwIiwiZm9jdXNUcmFwIiwiYWN0aXZlIiwiZGVhY3RpdmF0ZSIsInJldHVybkZvY3VzIiwiZXZlbnQiLCJhbGxvd0RlYWN0aXZhdGlvbiIsInRhcmdldCIsIl90aGlzMiIsImZpbmlzaERlYWN0aXZhdGlvbiIsInJldHVybkZvY3VzTm9kZSIsImNhblJldHVybkZvY3VzIiwiZm9jdXMiLCJ0YWJiYWJsZU9wdGlvbnMiLCJfdGhpczIkaW50ZXJuYWxPcHRpb24iLCJwcmV2ZW50U2Nyb2xsIiwidGhlbiIsInNldHVwRm9jdXNUcmFwIiwiYWN0aXZhdGUiLCJwYXVzZWQiLCJwYXVzZSIsIm5vZGVzRXhpc3QiLCJzb21lIiwiX2NyZWF0ZUZvY3VzVHJhcCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwidXBkYXRlQ29udGFpbmVyRWxlbWVudHMiLCJoYXNBY3RpdmF0ZWQiLCJoYXNEZWFjdGl2YXRlZCIsImhhc1BhdXNlZCIsImhhc1VucGF1c2VkIiwidW5wYXVzZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwiX3RoaXMzIiwiY2hpbGQiLCJjaGlsZHJlbiIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJGcmFnbWVudCIsImNhbGxiYWNrUmVmIiwiZWxlbWVudCIsInJlZiIsImN1cnJlbnQiLCJjaGlsZFdpdGhSZWYiLCJjbG9uZUVsZW1lbnQiLCJDb21wb25lbnQiLCJFbGVtZW50VHlwZSIsIkVsZW1lbnQiLCJGdW5jdGlvbiIsInByb3BUeXBlcyIsImJvb2wiLCJzaGFwZSIsIm9iamVjdCIsIm9uQWN0aXZhdGUiLCJmdW5jIiwib25Qb3N0QWN0aXZhdGUiLCJjaGVja0NhbkZvY3VzVHJhcCIsIm9uUGF1c2UiLCJvblBvc3RQYXVzZSIsIm9uVW5wYXVzZSIsIm9uUG9zdFVucGF1c2UiLCJpbml0aWFsRm9jdXMiLCJvbmVPZlR5cGUiLCJpbnN0YW5jZU9mIiwic3RyaW5nIiwiZmFsbGJhY2tGb2N1cyIsImVzY2FwZURlYWN0aXZhdGVzIiwic2V0UmV0dXJuRm9jdXMiLCJhbGxvd091dHNpZGVDbGljayIsImRpc3BsYXlDaGVjayIsIm9uZU9mIiwiZ2V0U2hhZG93Um9vdCIsInRyYXBTdGFjayIsImFycmF5IiwiaXNLZXlGb3J3YXJkIiwiaXNLZXlCYWNrd2FyZCIsImFycmF5T2YiLCJkZWZhdWx0UHJvcHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js\n");

/***/ })

};
;